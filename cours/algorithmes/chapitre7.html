<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapitre 7 - Tous les algorithmes de tri</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      margin: 0;
      background: #f5f7fa;
      color: #333;
    }
    header {
      background-color: #008080;
      color: white;
      padding: 2rem;
      text-align: center;
    }
    main {
      max-width: 800px;
      margin: 2rem auto;
      padding: 2rem;
      background: white;
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    h1, h2 {
      color: #008080;
    }
    pre {
      background: #eee;
      padding: 1rem;
      border-radius: 5px;
      overflow-x: auto;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 0.8rem;
      text-align: left;
    }
    th {
      background-color: #008080;
      color: white;
    }
    .btn {
      display: inline-block;
      margin-top: 2rem;
      padding: 0.8rem 1.5rem;
      background-color: #008080;
      color: white;
      text-decoration: none;
      border-radius: 8px;
    }
    footer {
      text-align: center;
      padding: 2rem;
      font-size: 0.9rem;
    }
    footer a {
      color: #008080;
      text-decoration: none;
    }
    footer a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <header>
    <h1>Chapitre 7 : Tous les algorithmes de tri ğŸ“ˆ</h1>
    <p>Organise des donnÃ©es efficacement avec les algorithmes de tri les plus utilisÃ©s !</p>
  </header>

  <main>
    <h2>ğŸ”¹ Quâ€™est-ce quâ€™un tri ?</h2>
    <p>Un <strong>algorithme de tri</strong> ordonne les Ã©lÃ©ments dâ€™un tableau, gÃ©nÃ©ralement du plus petit au plus grand. Câ€™est essentiel pour organiser des donnÃ©es, comme trier des noms ou des scores.</p>
    <p><strong>Analogie</strong> : Imagine que tu ranges des cartes numÃ©rotÃ©es mÃ©langÃ©es sur une table dans lâ€™ordre croissant. Chaque algorithme a une mÃ©thode diffÃ©rente pour y arriver.</p>

    <h2>ğŸ”¹ 1. Tri Ã  bulles</h2>
    <p>Le <strong>tri Ã  bulles</strong> compare des paires dâ€™Ã©lÃ©ments voisins et les Ã©change sâ€™ils sont dans le mauvais ordre, comme des bulles qui remontent Ã  la surface.</p>
    <p><strong>Avantages</strong> : Simple Ã  comprendre et Ã  coder.</p>
    <p><strong>InconvÃ©nients</strong> : Lent pour de grands tableaux (complexitÃ© O(nÂ²)).</p>
    <pre><code>
# Pseudo-code
Algorithme TriBulle(tableau)
    DÃ©but
        n â† longueur(tableau)
        Pour i de 0 Ã  n-1 Faire
            Pour j de 0 Ã  n-i-1 Faire
                Si tableau[j] > tableau[j+1] Alors
                    Ã‰changer tableau[j] et tableau[j+1]
                FinSi
            FinPour
        FinPour
    Fin

# Python
def tri_bulle(tableau):
    n = len(tableau)
    for i in range(n):
        for j in range(0, n-i-1):
            if tableau[j] > tableau[j+1]:
                tableau[j], tableau[j+1] = tableau[j+1], tableau[j]
    return tableau
tab = [64, 34, 25, 12]
print(tri_bulle(tab))  # Affiche : [12, 25, 34, 64]
    </code></pre>

    <h2>ğŸ”¹ 2. Tri par sÃ©lection</h2>
    <p>Le <strong>tri par sÃ©lection</strong> trouve le plus petit Ã©lÃ©ment du tableau et le place au dÃ©but, puis rÃ©pÃ¨te pour le reste.</p>
    <p><strong>Analogie</strong> : Câ€™est comme choisir le plus petit livre dâ€™une pile et le poser sur une Ã©tagÃ¨re, un par un.</p>
    <p><strong>Avantages</strong> : Intuitif, peu dâ€™Ã©changes.</p>
    <p><strong>InconvÃ©nients</strong> : Toujours O(nÂ²), mÃªme pour des tableaux presque triÃ©s.</p>
    <pre><code>
# Pseudo-code
Algorithme TriSelection(tableau)
    DÃ©but
        n â† longueur(tableau)
        Pour i de 0 Ã  n-1 Faire
            min â† i
            Pour j de i+1 Ã  n-1 Faire
                Si tableau[j] < tableau[min] Alors
                    min â† j
                FinSi
            FinPour
            Ã‰changer tableau[i] et tableau[min]
        FinPour
    Fin

# Python
def tri_selection(tableau):
    n = len(tableau)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if tableau[j] < tableau[min_idx]:
                min_idx = j
        tableau[i], tableau[min_idx] = tableau[min_idx], tableau[i]
    return tableau
tab = [64, 34, 25, 12]
print(tri_selection(tab))  # Affiche : [12, 25, 34, 64]
    </code></pre>

    <h2>ğŸ”¹ 3. Tri par insertion</h2>
    <p>Le <strong>tri par insertion</strong> insÃ¨re chaque Ã©lÃ©ment Ã  sa place dans une partie dÃ©jÃ  triÃ©e du tableau.</p>
    <p><strong>Analogie</strong> : Comme trier des cartes dans ta main, en plaÃ§ant chaque nouvelle carte au bon endroit.</p>
    <p><strong>Avantages</strong> : Efficace pour les petits tableaux ou presque triÃ©s (O(n) dans le meilleur cas).</p>
    <p><strong>InconvÃ©nients</strong> : O(nÂ²) dans le pire cas.</p>
    <pre><code>
# Pseudo-code
Algorithme TriInsertion(tableau)
    DÃ©but
        n â† longueur(tableau)
        Pour i de 1 Ã  n-1 Faire
            cle â† tableau[i]
            j â† i - 1
            Tant que j â‰¥ 0 ET tableau[j] > cle Faire
                tableau[j+1] â† tableau[j]
                j â† j - 1
            FinTantQue
            tableau[j+1] â† cle
        FinPour
    Fin

# Python
def tri_insertion(tableau):
    n = len(tableau)
    for i in range(1, n):
        cle = tableau[i]
        j = i - 1
        while j >= 0 and tableau[j] > cle:
            tableau[j+1] = tableau[j]
            j -= 1
        tableau[j+1] = cle
    return tableau
tab = [64, 34, 25, 12]
print(tri_insertion(tab))  # Affiche : [12, 25, 34, 64]
    </code></pre>

    <h2>ğŸ”¹ 4. Tri rapide (QuickSort)</h2>
    <p>Le <strong>tri rapide</strong> choisit un pivot, divise le tableau en Ã©lÃ©ments plus petits et plus grands, puis trie rÃ©cursivement.</p>
    <p><strong>Analogie</strong> : Comme diviser une pile de cartes en deux sous-piles autour dâ€™une carte pivot, puis rÃ©pÃ©ter.</p>
    <p><strong>Avantages</strong> : TrÃ¨s rapide en moyenne (O(n log n)).</p>
    <p><strong>InconvÃ©nients</strong> : O(nÂ²) dans le pire cas (pivot mal choisi).</p>
    <pre><code>
# Pseudo-code
Algorithme TriRapide(tableau, debut, fin)
    DÃ©but
        Si debut < fin Alors
            pivot â† Partition(tableau, debut, fin)
            TriRapide(tableau, debut, pivot-1)
            TriRapide(tableau, pivot+1, fin)
        FinSi
    Fin
Algorithme Partition(tableau, debut, fin)
    DÃ©but
        pivot â† tableau[fin]
        i â† debut - 1
        Pour j de debut Ã  fin-1 Faire
            Si tableau[j] â‰¤ pivot Alors
                i â† i + 1
                Ã‰changer tableau[i] et tableau[j]
            FinSi
        FinPour
        Ã‰changer tableau[i+1] et tableau[fin]
        Retourner i+1
    Fin

# Python
def tri_rapide(tableau, debut, fin):
    if debut < fin:
        pivot = partition(tableau, debut, fin)
        tri_rapide(tableau, debut, pivot-1)
        tri_rapide(tableau, pivot+1, fin)
def partition(tableau, debut, fin):
    pivot = tableau[fin]
    i = debut - 1
    for j in range(debut, fin):
        if tableau[j] <= pivot:
            i += 1
            tableau[i], tableau[j] = tableau[j], tableau[i]
    tableau[i+1], tableau[fin] = tableau[fin], tableau[i+1]
    return i+1
tab = [64, 34, 25, 12]
tri_rapide(tab, 0, len(tab)-1)
print(tab)  # Affiche : [12, 25, 34, 64]
    </code></pre>

    <h2>ğŸ”¹ 5. Tri par fusion (MergeSort)</h2>
    <p>Le <strong>tri par fusion</strong> divise le tableau en deux moitiÃ©s, trie chaque moitiÃ© rÃ©cursivement, puis fusionne les rÃ©sultats.</p>
    <p><strong>Analogie</strong> : Comme diviser un tas de cartes en deux, trier chaque tas, puis les recombiner en ordre.</p>
    <p><strong>Avantages</strong> : Stable et efficace (O(n log n)).</p>
    <p><strong>InconvÃ©nients</strong> : Utilise plus de mÃ©moire pour la fusion.</p>
    <pre><code>
# Pseudo-code
Algorithme TriFusion(tableau)
    DÃ©but
        Si longueur(tableau) > 1 Alors
            milieu â† longueur(tableau) / 2
            gauche â† tableau[0 Ã  milieu]
            droite â† tableau[milieu Ã  fin]
            TriFusion(gauche)
            TriFusion(droite)
            Fusionner(tableau, gauche, droite)
        FinSi
    Fin
Algorithme Fusionner(tableau, gauche, droite)
    DÃ©but
        i â† 0, j â† 0, k â† 0
        Tant que i < longueur(gauche) ET j < longueur(droite) Faire
            Si gauche[i] â‰¤ droite[j] Alors
                tableau[k] â† gauche[i]
                i â† i + 1
            Sinon
                tableau[k] â† droite[j]
                j â† j + 1
            FinSi
            k â† k + 1
        FinTantQue
        Ajouter les Ã©lÃ©ments restants de gauche et droite
    Fin

# Python
def tri_fusion(tableau):
    if len(tableau) > 1:
        milieu = len(tableau) // 2
        gauche = tableau[:milieu]
        droite = tableau[milieu:]
        tri_fusion(gauche)
        tri_fusion(droite)
        i = j = k = 0
        while i < len(gauche) and j < len(droite):
            if gauche[i] <= droite[j]:
                tableau[k] = gauche[i]
                i += 1
            else:
                tableau[k] = droite[j]
                j += 1
            k += 1
        while i < len(gauche):
            tableau[k] = gauche[i]
            i += 1
            k += 1
        while j < len(droite):
            tableau[k] = droite[j]
            j += 1
            k += 1
    return tableau
tab = [64, 34, 25, 12]
print(tri_fusion(tab))  # Affiche : [12, 25, 34, 64]
    </code></pre>

    <h2>ğŸ”¹ 6. Tri par tas (HeapSort)</h2>
    <p>Le <strong>tri par tas</strong> utilise une structure de tas (arbre binaire) pour trier les Ã©lÃ©ments, en extrayant le maximum Ã  chaque Ã©tape.</p>
    <p><strong>Analogie</strong> : Comme organiser une compÃ©tition oÃ¹ le meilleur Ã©lÃ©ment est toujours sÃ©lectionnÃ© en premier.</p>
    <p><strong>Avantages</strong> : Efficace (O(n log n)), tri en place.</p>
    <p><strong>InconvÃ©nients</strong> : Plus complexe Ã  coder.</p>
    <pre><code>
# Pseudo-code
Algorithme TriTas(tableau)
    DÃ©but
        ConstruireTasMax(tableau)
        Pour i de longueur(tableau)-1 Ã  1 Faire
            Ã‰changer tableau[0] et tableau[i]
            Tasser(tableau, 0, i)
        FinPour
    Fin

# Python
def tri_tas(tableau):
    def tasser(tableau, n, i):
        plus_grand = i
        gauche = 2 * i + 1
        droite = 2 * i + 2
        if gauche < n and tableau[gauche] > tableau[plus_grand]:
            plus_grand = gauche
        if droite < n and tableau[droite] > tableau[plus_grand]:
            plus_grand = droite
        if plus_grand != i:
            tableau[i], tableau[plus_grand] = tableau[plus_grand], tableau[i]
            tasser(tableau, n, plus_grand)
    n = len(tableau)
    for i in range(n//2-1, -1, -1):
        tasser(tableau, n, i)
    for i in range(n-1, 0, -1):
        tableau[0], tableau[i] = tableau[i], tableau[0]
        tasser(tableau, i, 0)
    return tableau
tab = [64, 34, 25, 12]
print(tri_tas(tab))  # Affiche : [12, 25, 34, 64]
    </code></pre>

    <h2>ğŸ”¹ 7. Tri par comptage</h2>
    <p>Le <strong>tri par comptage</strong> compte les occurrences de chaque valeur et reconstruit le tableau triÃ©.</p>
    <p><strong>Analogie</strong> : Comme trier des piÃ¨ces de monnaie en comptant combien il y a de chaque type.</p>
    <p><strong>Avantages</strong> : TrÃ¨s rapide pour des nombres dans une plage limitÃ©e (O(n+k)).</p>
    <p><strong>InconvÃ©nients</strong> : NÃ©cessite une plage de valeurs connue, pas adaptÃ© aux nombres flottants.</p>
    <pre><code>
# Pseudo-code
Algorithme TriComptage(tableau)
    DÃ©but
        max â† maximum(tableau)
        compte â† tableau de taille max+1 initialisÃ© Ã  0
        Pour chaque Ã©lÃ©ment dans tableau Faire
            compte[Ã©lÃ©ment] â† compte[Ã©lÃ©ment] + 1
        FinPour
        k â† 0
        Pour i de 0 Ã  max Faire
            Pour j de 1 Ã  compte[i] Faire
                tableau[k] â† i
                k â† k + 1
            FinPour
        FinPour
    Fin

# Python
def tri_comptage(tableau):
    max_val = max(tableau)
    compte = [0] * (max_val + 1)
    for x in tableau:
        compte[x] += 1
    k = 0
    for i in range(max_val + 1):
        for j in range(compte[i]):
            tableau[k] = i
            k += 1
    return tableau
tab = [4, 2, 2, 8, 3, 3]
print(tri_comptage(tab))  # Affiche : [2, 2, 3, 3, 4, 8]
    </code></pre>

    <h2>ğŸ“Š Comparaison des algorithmes</h2>
    <table>
      <tr>
        <th>Algorithme</th>
        <th>ComplexitÃ© (pire cas)</th>
        <th>ComplexitÃ© (meilleur cas)</th>
        <th>Stable</th>
        <th>En place</th>
      </tr>
      <tr>
        <td>Tri Ã  bulles</td>
        <td>O(nÂ²)</td>
        <td>O(n)</td>
        <td>Oui</td>
        <td>Oui</td>
      </tr>
      <tr>
        <td>Tri par sÃ©lection</td>
        <td>O(nÂ²)</td>
        <td>O(nÂ²)</td>
        <td>Non</td>
        <td>Oui</td>
      </tr>
      <tr>
        <td>Tri par insertion</td>
        <td>O(nÂ²)</td>
        <td>O(n)</td>
        <td>Oui</td>
        <td>Oui</td>
      </tr>
      <tr>
        <td>Tri rapide</td>
        <td>O(nÂ²)</td>
        <td>O(n log n)</td>
        <td>Non</td>
        <td>Oui</td>
      </tr>
      <tr>
        <td>Tri par fusion</td>
        <td>O(n log n)</td>
        <td>O(n log n)</td>
        <td>Oui</td>
        <td>Non</td>
      </tr>
      <tr>
        <td>Tri par tas</td>
        <td>O(n log n)</td>
        <td>O(n log n)</td>
        <td>Non</td>
        <td>Oui</td>
      </tr>
      <tr>
        <td>Tri par comptage</td>
        <td>O(n+k)</td>
        <td>O(n+k)</td>
        <td>Oui</td>
        <td>Non</td>
      </tr>
    </table>

    <h2>ğŸ“Œ Points clÃ©s</h2>
    <ul>
      <li>Les tris simples (bulles, sÃ©lection, insertion) sont faciles Ã  coder mais lents (O(nÂ²)).</li>
      <li>Les tris avancÃ©s (rapide, fusion, tas) sont plus rapides (O(n log n)) mais complexes.</li>
      <li>Le tri par comptage est idÃ©al pour des valeurs dans une plage limitÃ©e.</li>
      <li>Choisis lâ€™algorithme selon la taille du tableau, la stabilitÃ©, et la mÃ©moire disponible.</li>
    </ul>

    <h2>ğŸš€ Pour aller plus loin</h2>
    <p>Essaie dâ€™implÃ©menter un tri en ordre dÃ©croissant, ou compare les performances des algorithmes sur un grand tableau (ex. : 1000 Ã©lÃ©ments). Tu peux aussi explorer dâ€™autres tris, comme le tri radix.</p>

    <h2>ğŸ“¥ Essaie par toi-mÃªme !</h2>
    <p>Copie les codes Python dans un environnement :</p>
    <ul>
      <li><a href="https://replit.com" target="_blank">Replit</a> (idÃ©al pour mobile).</li>
      <li><a href="https://trinket.io" target="_blank">Trinket</a> (simple et sans installation).</li>
    </ul>

    <a href="chapitre8.html" class="btn">â¡ï¸ Chapitre 8 : Recherches</a>
  </main>

  <footer>
    <p><a href="index.html">â† Retour au menu Algorithmes</a></p>
  </footer>
</body>
</html>